Linux rename命令 批量重命名

2, Perl 版本的批量重命名，带有Perl的好处是，你可以使用正则表达式来完成很奇特的功能。

perl 版本的参数格式：

rename  perlexpr files

注意，perl版本的rename只有两个参数，第一个参数为perl正则表达式，第二个参数为所要处理的文件

man rename的帮助示例：

1) 有一批文件，以 .bak结尾，现在想把这些 .bak 统统去掉。

rename     's/\.bak$//'        *.bak

这个命令很简单，因为我还没有系统学习过perl，我不知道perl里替换字符串是不是这么干的，但sed是这么干的，所以如果你有sed或者tr基础，很容易明白，这个替换和sed里的正则语法是一模一样的。

2) 把所有文件名内含有大小字母的，修改为小写字母。

rename      'y/A-Z/a-z/'        *

依然和sed的替换语法一样，不用多解释，如果看不懂的话，可以系统学习一下sed先。

还有几个比较实用的例子：

1） 批量去掉文件名里的空格
Linux文件名本来是不支持空格的，不知道什么时候允许了，当然，在命令行调用文件的时候，空格是很有问题滴，比如你 原来可以直接  mv  oldfile  newfile  但有空格就不行了 ， 得加双引号： mv "oldfile"  "newfile" 或者用反斜杠转移  \[] ，这样还好，但如果你直接把含有空格的图片名引入 Latex文档，Latex生成pdf的时候会直接打印出文件名，之前这个问题苦恼了我很久，我生成的pdf怎么老是出现文件名呢？后来才发现原来是文件名内含有空格的问题！windows系统下生成的文件名是天生含有空格的，虽然很讨厌，但有些惠普扫描仪生成的图片默认就加入了空格，没有办法，只好去掉他，在系统研究rename命令前，我是用 mv 去除空格的。

网上流程的两个去空格的版本：

1) tr 版：

find . -type f -name "* *" -print |
while read name; do
na=$(echo $name | tr ' ' '_')
if [[ $name != $na ]]; then
mv "$name" $na
fi
done

这个版本以前我一直用的，不知道哪个网上搜刮来的，当时还没有系统的学习过 tr/sed/awk命令。
注解一下，很好理解， find . type f -name "* *" -print 这一句是查找当前目录下所有类型为普通文件的 并且名字之中含有空格的文件，并打印出来，其实 find默认就是打印的 这个 -print 多余了，然后 通过管道传输给 while 循环读取，文件名放到 name 变量里，用 tr 命令 替换空格为 下划线。 下面判断如果执行后的名称不相同，使用 mv 命令重命名。但这个if判断可有可无，因为find已经查询了所有文件名中含有空格的，那么经过 tr 命令后， $na变量肯定不等于 $name 变量的。

所以这段代码可以简化：

find . -type f -name "* *" |
while read name; do
na=$(echo $name | tr ' ' '_')
mv "$name" "$na"
done

tr 可以看着是 sed 的一个精简版本，tr 用下划线来替换空格。

还有一个 是 sed 版本实现：

for f in *;do mv "$f" `echo "$f" | sed 's/[ ]\+/_/g' `; done

这里的 sed表达式还可以这样写：

sed 's/[[:space:]]\+/_/g'

不过记住，sed里的出现一次或多次的加号是需要添加反斜杠的。即：\+

这样就可以了。

好了，这两种办法都太他妈罗嗦了，看看rename实现吧：

rename      's/[ ]+/_/g'        *

OK就这么简单。
方括号内的空格可以用 [:space:]代替，
即可以写成 's/[[:space:]]+/_/g'

这里注意，rename 采用的是标准perl正则语法，所以无须将 加号转变为反斜杠加号
即 + 不能修改为 \+，否则替换失败。
